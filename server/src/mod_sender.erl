-module(mod_sender).%%----------------------------------------------------%% @doc 角色消息进程发送模块%% @end%%-----------------------------------------------------author('hbc 670762853@qq.com').-behaviour(gen_server).-export([start_link/1]).-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).-export([port_command/1]).-record(state, {        port        ,role_id        ,role_pid        ,account        ,send_account = 0        ,error_account = 0    }).port_command(Bin) ->    ?MODULE ! {port_command, Bin}.start_link([RoleId, Account, RolePid, Socket]) ->    gen_server:start_link({local, ?MODULE}, ?MODULE, [RoleId, Account, RolePid, Socket], []).init([RoleId, Account, Pid, Socket]) ->    process_flag(trap_exit, true),    link(Socket),    State = #state{role_id = RoleId, account = Account, role_pid = RolePid, port = Socket},    {ok, State}.handle_call(_Request, _From, State) ->    {noreply, State}.handle_cast(_Msg, State) ->    {noreply, State}.handle_info({port_command, Bin}, State = #state{port = Socket, send_count = SendCount, error_count = ErrorCount}) ->    case erlang:port_command(Socket, Bin, [force]) of        true ->            {noreply, State#state{send_count = SendCount + 1}};        _ ->            case erlang:port_info(Socket) of                undefined ->                    {stop, disconnect, State};                _ ->                    {noreply, State#state{error_count = ErrorCount + 1}}            end    end;handle_info({'EXIT', _From, normal}, State) ->    {stop, normal, State};handle_info({'EXIT', Pid, Why}, State) ->    {stop, normal, State};handle_info(_Info, State) ->    {noreply, State}.terminate(_Reason, _State = #state{role_pid = RolePid, socket = Socket}) ->    mod_role:stop(RolePid),    gen_tcp:close(Socket)    ok.code_change(_OldVsn, State, _Extra) ->    {ok, State}.